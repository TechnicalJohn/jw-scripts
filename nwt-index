#!/bin/bash
#
# nwt-index
#
# Requires: GNU sed, curl/wget
#

error()
{
    echo "${@:-Something went wrong}" 1>&2
    exit 1
}

show_help()
{
    cat<<EOF
Index the bible recordings from jw.org and make m3u playlists

Usage: nwt-index [options] [DIRECTORY]
  --lang CODE   Select language code. Selecting none will
		show a list of available codes.
  --silver	Use the 2013 edition of the NWT.
  DIRECTORY     Directory to save the playlists in.
EOF
    exit
}

# Add newline around squiggly and square brackets and replace commas with newline
# but do nothing if they are quoted
unsquash_file()
{
    sed '
	# Add a newline after all "special" characters
	# Note how the character list starts with an ]
	# Smart huh?
	s/[][{},]/\n&\n/g

' | sed -n '
	: start
	# Does this row have an uneven number of citation marks?
	# That means that the quote continues on the next line...
	/^\([^"\n]*"[^"\n]*"\)*[^"\n]*"[^"\n]*$/ {
	    # Append the next line of input
	    N
	    # Remove the newline between the two lines of input
	    s/\n//g   
	    # Go back to start again
	    b start
	}
	# If the line is fine, print it
	p
' | sed -n '
	# Only print relevant lines, and remove citation marks
	s/^"\(pubName\|booknum\|title\|url\)":"\?\([^"]*\)"\?$/\1:\2/p
'
}

# Read the formated json file on stdin
# write mp3 files to playlists
# and download and parse new books
#
# GIGANT CAVEATS:
# - "pubName" must be first, because it erases the playlist
# - "title" must be followed by "booknum" or by "stream"
# - "pubName" must be the same as the parent books "title"
#     or else the link to the file and the actual file
#     will be different.
#
parse_lines()
{
    # If we are a child process, store playlists in subdir
    # (It doesn't matter that we change the savedir variable
    # because the child processes doesn't fork)
    [[ $book != 0 ]] && savedir="$savedir/$subsavedir"
    
    # Create directory
    if [[ ! -e $savedir ]]; then
	mkdir -p "$savedir" || error "$savedir: Failed to create directory"
    fi
    
    # Read stdin
    # Use -r because we want to keep the backslashes a bit longer
    while read -r input; do
	# Unescape
	input="$(printf '%b' "$input")"
	# Remove backslashes
	input="${input//\\/}"

	case "$input" in
	    pubName:*)
		name="${input#*:}"
		# Message, so we can see progress
		echo "$name" 1>&2		    
		# Start on an empty playlist
		echo "#EXTM3U" > "$savedir/$name.m3u"
		;;
	    title:*)
		title="${input#*:}"
		;;
	    booknum:*)
		newbook="${input#*:}"
		# Only create links to books if our book is the "index"
		# and the link don't point to the index itself.
		if [[ $book = 0 && ! $newbook = 0 ]]; then
		    print_to_file "$title" "$subsavedir/$title.m3u"
		    # Index the new book
		    ("$0" --book "$newbook")
		fi
		;;
	    url:*.mp3)
		url="${input#*:}"
		print_to_file "$title" "$url"
		;;
	esac
    done
}

# Print text to the playlist
# Args: NAME PATH
print_to_file()
{
    # Write to file
    printf '%s\n' "#EXTINF:0,$1" "$2" >> "$savedir/$name.m3u"
}

# Download the language list and make it readable
# Note: This is probably not very failsafe
lang_list()
{
    echo "Languages:"
    # 1. Download the list
    # 2. Replace commas with newlines
    # 3. Replace "CODE":{"name":"LANG" with CODE:LANG
    # 4. Sort it
    # 6. Make a nice list with columns
    download_file "$langurl" \
        | sed 's/,/\n/g' \
        | sed -n 's/.*"\([^"]*\)":{"name":"\([^"]*\)"/\1:\2/p' \
        | sort \
        | column -t -s :
}

# Download a file with curl or wget
download_file()
{
    if ((CURL)); then
	curl --silent "$1" || error "Failed to download file"
    else
	wget --quiet -O - "$1" || error "Failed to download file"
    fi
}

# Check requirements
type sed &>/dev/null || error "This script requires GNU sed"
if type curl &>/dev/null; then
    CURL=1
else
    type wget &>/dev/null || error "This script requires curl or wget"
    CURL=0
fi
sed --version | egrep -q "GNU sed" || cat <<EOF
Warning:
This script is build for and tested only with GNU sed.
It looks like you are using a different version of sed,
so I canot guarrantee that it will work for you.
Just saying :)

EOF

# Arguments
while [[ $1 ]]; do
    case $1 in
        --help) show_help
            ;;
        --lang)
	    CHECKLANG=1
	    lang="$2"
	    shift
            ;;
	--book)
	    book="$2"
	    shift
	    ;;
	--silver)
	    bible=nwt
	    ;;
        --*) error "Unknown flag: $1"
            ;;
        *) break
            ;;
    esac
    shift
done

# Set variables
export lang savedir bible
[[ $savedir ]] || savedir="${1:-.}"
[[ $book ]] || book=0
[[ $bible ]] || bible=bi12
langurl="www.jw.org/apps/TRGCHlZRQVNYVrXF?output=json&pub=$bible&fileformat=MP3&alllangs=1&langwritten=E&txtCMSLang=E&booknum=0"

# Check if language is correct
if ((CHECKLANG)); then
    # If language isn't found in list, show help
    if [[ -z $lang ]] || ! download_file "$langurl" | grep -q "\"$lang\":{\"name\":"; then
	lang_list
	exit
    fi
    # Unset CHECKLANG so we don't make any more checks
    CHECKLANG=0
fi

# Language related stuff after language validation
[[ $lang ]] || lang=E
baseurl="http://www.jw.org/apps/TRGCHlZRQVNYVrXF?booknum=$book&output=json&pub=$bible&fileformat=MP3&alllangs=0&langwritten=$lang&txtCMSLang=$lang"
subsavedir="$savedir/$bible-$lang"

# Download and parse the JSON file
download_file "$baseurl" | unsquash_file | parse_lines || error

