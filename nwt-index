#!/bin/bash
#
# nwt-index
# Index the the sound recordings at jw.org of
# the New World Translation of the Holy Scriptures
#

load_shared_code()
{
    for code in "$SHARED" ./shared-functions /usr/local/lib/jw-scripts/shared-functions; do
	if [[ -f $code ]]; then
	    if source "$code"; then
		break
	    else
		echo "Failed to load shared functions" 1&>2
		exit 1
	    fi
	fi
    done

    if [[ $? != 0 ]]; then
	echo "Cannot find shared functions file" 1>&2
	echo "You can set the default path with the variable SHARED" 1>&2
	exit 1
    fi
}

show_help()
{
    cat<<EOF
Usage: nwt-index [OPTIONS] [DIRECTORY]
Index the bible sound recordings at jw.org and make playlists

Options:
  --lang CODE           Change language
  --list-langs          Show a list of available language codes
  --silver              Use the 2013 edition of the NWT
  --download            Make recordings available offline
  --mode MODE           The format in which files are saved (see Modes)
  --clean               Clean out all old files exept downloaded recordings
  DIRECTORY             Directory to save the playlists or recordings in

Advanced options:
  --limit-rate RATE     Maximum download rate for recordings
			  For example 1m means 1 megabyte per second
  --book NUM            Number of bible book to download
  --json                Don't parse the JSON file, just show it (debug)

Modes:
  m3u                   Write a m3u hierarcy of m3u playlists. You can browse
                          this by opening the first playlist. This works with
                          Kodi, but can confuse other media players.
  m3ucompat             Save multiple m3u playlists in the destination
                          directory. There is no hierarcy, so you will have to
                          open the correct playlist via a file browser, but
                          this should work with most players.
  filesystem            The media is saved in an actual folder hierarchy
                          consisting of directories and symlinks. This is
                          mostly useful in combination with --download for
                          media players that cannot read m3u files, e.g. Plex.

EOF
    exit
}

# Read the formated JSON file on stdin
# write mp3 files to playlists
# and download and parse new books
#
# GIGANT CAVEATS:
# - "pubName" must be first, because it erases the playlist
# - "title" must be followed by "booknum" or by "stream"
# - "pubName" must be the same as the parent books "title"
#     or else the link to the file and the actual file
#     will be different.
#
parse_lines()
{
    # Create empty playlist for this category
    ! ((filesystem)) && reset_playlist "$datadir/$maincode.m3u"

    # Read stdin
    # Use -r because we want to keep the backslashes a bit longer
    while read -r input; do
        # Unescape
        input="$(printf '%b' "$input")"
        # Remove backslashes
        input="${input//\\/}"

        case "$input" in

            pubName:*)
                name="${input#*:}"
                # Message, so we can see progress
                echo "$name" 1>&2

		# First process
                # Create a link for easy access to first playlist/dir
                ! ((child)) && create_index_file_link "$maincode" "$name" "$datadir"
                ;;

            title:*)
                title="${input#*:}"
                ;;

            booknum:*)
                code="${input#*:}"

		# Pad code to 2 digits
		code="$(printf '%02d' "$code")"

                # Skip subdirs if we are child or code refers to self
                ((child)) || [[ $code = "$maincode" ]] && continue

                write_subdir "$title" "$code" "$datadir" "$maincode"
                ("$0" --child --book "$code" "$datadir")
                ;;

            url:*.mp3)
                url="${input#*:}"
                write_media "$title" "$url" "$datadir" "$maincode" "$name"
                ;;

        esac
    done
}

# Download the language list and make it readable
# CAVEATS
# - "name" must be the first variable in the language list
lang_list()
{
    echo "Languages:"
    # 1. Download the list
    # 2. Replace commas with newlines
    # 3. Replace "CODE":{"name":"LANG" with CODE:LANG
    # 4. Sort it
    # 5. Make a nice list with columns
    download_file "$langurl" \
        | sed 's/,/\n/g' \
        | sed -n 's/.*"\([^"]*\)":{"name":"\([^"]*\)"/\1:\2/p' \
        | sort \
        | column -t -s :
    exit
}

load_shared_code

read_arguments --help:show_help \
               --lang=lang \
               --list-langs:lang=none \
               --book=maincode \
               --silver:bible=nwt \
               --download:download=1 \
               --json:json=1 \
               --filesystem:mode=filesystem \
	       --mode=mode \
	       --limit-rate=maxrate \
	       --child:child=1 \
	       --clean:clean=1 \
               -- \
               "$@" || exit 1

export lang maincode bible maxrate download filesystem mode
[[ ${#arguments[@]} -gt 1 ]] && error "Too many arguments" # $arguments gets set by read_arguments()

# Assign variables
[[ $mode ]] || mode=m3u
[[ $bible ]] || bible=bi12
[[ $lang ]] || lang=E
[[ $datadir ]] || datadir="${arguments[0]:-.}"
[[ $maxrate = 0 ]] && unset maxrate
[[ $maincode ]] || maincode=0
langurl="http://www.jw.org/apps/TRGCHlZRQVNYVrXF?output=json&pub=$bible&fileformat=MP3&alllangs=1&langwritten=E&txtCMSLang=E&booknum=0"
mainurl="http://www.jw.org/apps/TRGCHlZRQVNYVrXF?booknum=$maincode&output=json&pub=$bible&fileformat=MP3&alllangs=0&langwritten=$lang&txtCMSLang=$lang"

# Pad code to 2 digits
code="$(printf '%02d' "$code")"

# Things that only the parent may do
# or that's only needed once
if ! ((child)); then
    # Do we have all we need?
    requirement_check
    # Check that lang is valid
    check_lang "$lang" "$langurl" "\"$lang\":{\"name\":" || lang_list
    # Check datadir
    [[ -d $datadir ]] || error "$datadir: Destination directory does not exist"
    # Make path absolute
    datadir="$(realpath "$datadir")"
    # Add a subdir
    datadir="$datadir/jwb-$lang"
    # Create subdir
    if [[ ! -d $datadir ]]; then
        mkdir -p "$datadir" || error "$datadir: Failed to create directory"
    fi
    # Cleaning
    ((clean)) && clean_dir "$datadir"
fi

# Debug JSON
if ((json)); then
    download_file "$mainurl" | unsquash_file | less
    exit
fi

# Download and parse the JSON file
download_file "$mainurl" \
    | unsquash_file pubName title booknum url \
    | parse_lines
