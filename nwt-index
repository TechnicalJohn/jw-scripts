#!/bin/bash
#
# nwt-index
# Index the the sound recordings at jw.org of
# the New World Translation of the Holy Scriptures
#

load_shared_code()
{
    for code in "$SHARED" ./shared-functions /usr/local/lib/jw-scripts/shared-functions; do
	if [[ -f $code ]]; then
	    if source "$code"; then
		return 0
	    else
		echo "Failed to load shared functions" 1>&2
		exit 1
	    fi
	fi
    done

    echo "Cannot find shared functions file" 1>&2
    echo "You can set the default path with the variable SHARED" 1>&2
    exit 1
}

show_help()
{
    cat<<EOF
Usage: nwt-index [OPTIONS] [DIRECTORY]
Index the bible sound recordings at jw.org

Options:
  --lang CODE           Change language
  --list-langs          Show a list of available language codes
  --silver              Use the 2013 edition of the NWT
  --download            Make recordings available offline
  --mode MODE           The format in which files are saved (see Modes)
  --clean               Clean out all old files exept downloaded recordings
  DIRECTORY             Directory to save the playlists or recordings in

Advanced options:
  --limit-rate RATE     Maximum download rate for recordings, for example
			  1m means 1 megabyte per second
  --book NUM            Number of bible book to download
  --json                Don't parse the JSON file, just show it (debug)

Modes:
  m3u                   Write a m3u hierarcy of m3u playlists. You can browse
                          this by opening the first playlist. This works with
                          Kodi, but can confuse other media players.
  m3ucompat             Save multiple m3u playlists in the destination
                          directory. There is no hierarcy, so you will have to
                          open the correct playlist via a file browser, but
                          this should work with most players.
  filesystem            The media is saved in an actual folder hierarchy
                          consisting of directories and symlinks. This is
                          really only useful in combination with --download for
                          media players that cannot read m3u files, e.g. Plex.
  urllist               Simply output a list of URLs or files to stdout.

EOF
    exit
}

# GIGANT CAVEATS:
# - Fist there must be a "pubName". This will give us the name
#     of the playlist to write to, and clean it.
# - "title" must be followed by "booknum" or by "url".
#    "booknum" is a sub-book and will be downloaded and parsed.
#    "url" is a media link and will be saved to a playlist,
#     and alternativly downloaded.
#
parse_lines()
{
    # Read stdin
    # Use -r because we want to keep the backslashes for a while longer
    while read -r input; do
        # Unescape
        input="$(printf '%b' "$input")"
        # Remove backslashes
        input="${input//\\/}"

        case "$input" in

            pubName:*)
                name="${input#*:}"
                # Message, so we can see progress
                echo "$name" 1>&2

		# Empty out playlist
		write_empty "$datadir" "$maincode" "$name"
		;;
	    
            title:*)
                title="${input#*:}"
                ;;

            booknum:*)
		# No sub-sub-dirs
		((child)) && continue

		# Pad code to 2 digits
		# $(( 10#n )) makes sure that numbers starting with
		# 0 isn't interpreted as octal
                code="$(printf '%02d' "$(( 10#${input#*:} ))")"

		# Don't add self as a subdir
		[[ $code = "$maincode" ]] && continue

		# A quick fix:
		# Add line number to books in filesystem mode, so they get sorted
		[[ $mode = filesystem ]] && title="$code - $title"
	
                write_subdir "$title" "$code" "$datadir" "$maincode" "$name"
                ("$0" --child --book "$code" "$datadir")
                ;;

            url:*.mp3)
                url="${input#*:}"
                write_media "$title" "$url" "$datadir" "$maincode" "$name"
                ;;

        esac
    done
}

check_lang()
{
    [[ $1 ]] || error "Error in $FUNCNAME"
    
    [[ $1 = E || $NOCHECKLANG = 1 ]] && return 0
    # Don't make more checks
    export NOCHECKLANG=1

    local langurl="http://www.jw.org/apps/TRGCHlZRQVNYVrXF?output=json&pub=$bible&fileformat=MP3&alllangs=1&langwritten=E&txtCMSLang=E&booknum=0"
    
    # Try to find the language code in the text
    if download_file "$langurl" | grep -q "\"$1\":{\"name\":" ; then
	return 0
    else
	# Download the language list and make it readable
	# CAVEATS
	# - "name" must be the first variable in the language list
	echo "Languages:"
	# 1. Download the list
	# 2. Replace commas with newlines
	# 3. Replace "CODE":{"name":"LANG" with CODE:LANG
	# 4. Sort it
	# 5. Make a nice list with columns
	download_file "$langurl" \
            | sed 's/,/\n/g' \
            | sed -n 's/.*"\([^"]*\)":{"name":"\([^"]*\)"/\1:\2/p' \
            | sort \
            | column -t -s :
	
	return 1
    fi
}

load_shared_code

read_arguments --help:show_help \
               --lang=lang \
               --list-langs:lang=none \
               --book=maincode \
               --silver:bible=nwt \
               --download:download=1 \
               --json:json=1 \
               --filesystem:mode=filesystem \
	       --mode=mode \
	       --limit-rate=maxrate \
	       --child:child=1 \
	       --clean:clean=1 \
               -- \
               "$@" || exit 1

export lang maincode bible maxrate download mode
[[ ${#arguments[@]} -gt 1 ]] && error "Too many arguments" # $arguments gets set by read_arguments()

# Assign variables
[[ $mode ]] || mode=m3u
[[ $bible ]] || bible=bi12
[[ $lang ]] || lang=E
[[ $datadir ]] || datadir="${arguments[0]:-.}"
[[ $maxrate = 0 ]] && unset maxrate
[[ $maincode ]] || maincode=0
mainurl="http://www.jw.org/apps/TRGCHlZRQVNYVrXF?booknum=$maincode&output=json&pub=$bible&fileformat=MP3&alllangs=0&langwritten=$lang&txtCMSLang=$lang"

[[ $mode =~ ^(m3u|m3ucompat|filesystem|urllist)$ ]] || error "$mode: Unknown mode"

# Pad code to 2 digits
# $(( 10#n )) makes sure that n isn't read as an octal
# number if it begins with 0
maincode="$(printf '%02d' "$(( 10#$maincode ))")"

# Things that only the parent may do
# or that's only needed once
if ! ((child)); then
    # Do we have all we need?
    requirement_check
    # Check that lang is valid
    check_lang "$lang"
    # Check datadir
    [[ -d $datadir ]] || error "$datadir: Destination directory does not exist"
    # Make path absolute
    datadir="$(realpath "$datadir")" || error
    # Add a subdir
    datadir="$datadir/jwb-$lang"
    # Cleaning
    ((clean)) && clean_dir "$datadir"
fi

# Debug JSON
if ((json)); then
    download_file "$mainurl" | unsquash_file | less
    exit
fi

# Download and parse the JSON file
download_file "$mainurl" \
    | unsquash_file pubName title booknum url \
    | parse_lines
