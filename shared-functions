# -*- shell-script -*-
#
# functions for jw-scripts
#
# Variables that changes the behaviour:
# mode         Valid values: m3u, m3ucompat, filesystem
# download     If true download the media files
# child        If true we are subprocess (affects some things)
# hascurl      If true use curl, else use wget
# maxrate      Set download rate
# 

error()
{
    echo "${BASH_SOURCE[1]}, line ${BASH_LINENO[0]}: ${*:-something went wrong}" 1>&2
    exit 1
}

msg()
{
    s=$?
    echo "$*" 1>&2
    return $s
}

# Remove everything but the media
clean_dir()
{
    local datadir="$1"

    [[ $datadir ]] || error

    # If dir doesn't exist, it is clean, right?
    [[ ! -d "$datadir" ]] && return 0
    
    # Remove links
    find "$datadir" -type l -delete
    # Remove playlists
    find "$datadir" -name "*.m3u" -delete
    # Remove empty directories
    find "$datadir" -type d -exec rmdir --ignore-fail-on-non-empty {} +
    # Remove symlinks outside $datadir that point to $datadir
    find "$(dirname "$datadir")" -maxdepth 1 -lname "$datadir/*" -or -lname "$(basename "$datadir")/*" -delete
}

# Make a link (but smarter)
# Args: DEST LINKNAME
create_link()
{
    local dest="$1"
    local link="$2"
    local linkdir="$(dirname "$link")"

    [[ $dest && $link && $linkdir ]] || error

    # Create dir if not there
    if [[ ! -d $linkdir ]]; then
	mkdir -p "$linkdir" || error "$linkdir: failed to create directory"
    fi
        
    # Does link exist?
    if [[ -L "$link" ]]; then
	# Is link destination same as we want?
	if [[ $(readlink "$link") = "$dest" ]]; then
	    return 0
	else
	    # If not, remove it
	    rm "$link" || error "$link: failed to remove link"
	fi
    fi

    # Make the actual link
    # -r makes it relative to link location
    ln -sr "$dest" "$link" || error "$link: failed to create link"
}

# Add newline around squiggly and square brackets and commas
# but not if they are quoted
# Keep only the lines starting with "KEYWORD":
# and remove all unescaped citation marks
# Args: [KEYWORD ...]
unsquash_file()
{
    local keywordstring

    if [[ $@ ]]; then
        # Append \| to all parameters
        # and remove the last one
        keywordstring="$(printf '%s\|' "$@" | sed 's/\\|$//')" || error
    else
        # Match everything that's not a citation mark
        keywordstring='[^"]*'
    fi

    sed '
        # Add a newline after all "special" characters
        # Note how the character list starts with an ]
        # Smart huh?
        s/[][{},]/\n&\n/g

' | sed -n '
        : start
        # Does this row have an uneven number of citation marks?
        # That means that the quote continues on the next line...
        /^\([^"\n]*"[^"\n]*"\)*[^"\n]*"[^"\n]*$/ {
            # Append the next line of input
            N
            # Remove the newline between the two lines of input
            s/\n//g
            # Go back to start again
            b start
        }
        # If the line is fine...
        # Grep only the keywords
        /^"\('"$keywordstring"'\)":/ {
            # Remove all unescaped citation marks
            s/\(^\|[^\]\)"\+/\1/g
            # And print it
            p
        }
' || error "failed to format JSON"
}

# Save link to other playlist/dir
# in current playlist/dir
# Args: NAME DESTCODE DATADIR CODE MAINNAME
write_subdir()
{
    local title="$1"
    local link="$2"
    local datadir="$3"
    local code="$4"
    local name="$5"
    
    [[ $title && $link && $datadir && $code && $name ]] || error

    case "$mode" in
	filesystem)
	    # Create the directory to link to, before linking to it
	    if [[ ! -d $datadir/$link ]]; then
		mkdir -p "$datadir/$link" || error "$datadir/$link: failed to create directory"
	    fi

	    # First process saves outside datadir
            if ! ((child)); then
		create_link "$datadir/$link" "$(dirname "$datadir")/$name/$title"
	    else
		create_link "$datadir/$link" "$datadir/$code/$title"
	    fi
	    ;;
	m3u|html)
	    # First process saves playlist outside of datadir
	    if ! ((child)); then
		write_to_$mode "$title" "$link.$mode" "$(dirname "$datadir")/$name.$mode"
	    else
		write_to_$mode "$title" "$link.$mode" "$datadir/$code.$mode"
	    fi
	    ;;
	m3ucompat)
	    return 0
	    ;;
	urllist)
	    return 0
	    ;;
    esac
    
    return 0
}

# Save media in playlist/dir
# and optionally download them
# Args: TITLE LINK DATADIR CODE NAME [CHECKSUM]
write_media()
{
    local title="$1"
    local link="$2"
    local file="$(basename "$link")"
    local datadir="$3"
    local code="$4"
    local name="$5"
    local destdir="$datadir"
    local checksum="$6"
    local size="$7"
    
    [[ $title && $link && $file && $datadir && $code && $name ]] || error

    [[ $mode = urllist ]] && datadir="$(dirname "$datadir")"
    
    # Check size
    if [[ $size =~ [0-9]+ && -e $datadir/$file ]]; then
	if [[ ! $(du --bytes "$datadir/$file" | cut -f1) -eq $size ]]; then
	    msg "$datadir/$file: incorrect file size, removing file"
	    rm -f "$datadir/$file"
	fi
    fi	

    # Check checksum
    if [[ $checksum =~ [0-9a-f]{32} && -e $datadir/$file ]]; then
	if ! echo "$checksum  $datadir/$file" | md5sum -c --status; then
	    msg "$datadir/$file: incorrect checksum, removing file"
	    rm -f "$datadir/$file"
	fi
    fi

    # Download media
    if ((download)); then
        if [[ ! -e $datadir/$file ]]; then
	    [[ -d $datadir ]] || mkdir -p "$datadir" || error "$datadir: failed to create directory"
            ((quiet)) || msg "downloading: $file"
            download_file "$link" "$datadir/$file"
	    # Re-check checksum
	    if [[ -e $datadir/$file && $checksum =~ [0-9a-f]{32} ]]; then
		if ! echo "$checksum  $datadir/$file" | md5sum -c --status; then
		    msg "$datadir/$file: incorrect checksum, removing file"
		    rm -f "$datadir/$file"
		fi
	    fi
        fi
    fi

    # Change link to point to local media (if any)
    [[ -e $datadir/$file ]] && link="$file"
    
    case "$mode" in
	filesystem)
	    # First process saves outside of datadir
	    if ! ((child)); then
		destdir="$(dirname "$datadir")"
		code="$name"
	    fi

	    # Link to existing media
	    if [[ -e $datadir/$file ]]; then
		suffix="$(sed -n 's/.\+\.//p' <<< "$file")"
		create_link "$datadir/$file" "$destdir/$code/$title.$suffix"
	    else
		# Create a playlist with a URL and link to it
		reset_m3u "$datadir/$file.m3u"
		write_to_m3u "$title" "$link" "$datadir/$file.m3u"
		create_link "$datadir/$file.m3u" "$destdir/$code/$title.m3u"
	    fi
	    ;;
	m3u|html)
	    # First process saves playlist outside of datadir
	    if ! ((child)); then
		# Note: no need to make link relative to datadir, this is done in write_to_$mode
		write_to_$mode "$title" "$link" "$(dirname "$datadir")/$name.$mode"
	    else
		write_to_$mode "$title" "$link" "$datadir/$code.$mode"
	    fi
	    ;;
	m3ucompat)
	    # Note: no need to make link relative to datadir, this is done in write_to_m3u
	    # Note: $code is in filename, not only to sort bible books in order, but also
	    #       to avoid conflicts, as multiple categories can have the same name in
	    #       JW Broadcasting, e.g. Featured Videos
	    write_to_m3u "$title" "$link" "$(dirname "$datadir")/$code - $name.m3u"
	    ;;
	urllist)
	    if [[ -e $datadir/$file ]]; then
		echo "$datadir/$file"
	    else
		echo "$link"
	    fi
	    ;;
    esac
    
    return 0
}

# Args: DATADIR CODE NAME
write_empty()
{
    local dir="$1"
    local code="$2"
    local name="$3"
    local file

    [[ $dir && $code && $name ]] || error

    case "$mode" in
	m3u|html)
	    # First process saves outside of datadir
	    if ! ((child)); then
		dir="$(dirname "$dir")"
		file="$name.$mode"
	    else
		file="$code.$mode"
	    fi
	    reset_$mode "$dir/$file"
	    ;;
	m3ucompat)
	    reset_m3u "$(dirname "$dir")/$code - $name.m3u"
	    ;;
	filesystem)
	    # Remove all links
	    [[ -e $dir/$code ]] && find "$dir/$code" -type l -delete
	    ;;
	urllist)
	    return 0
	    ;;
    esac
}

# Args: FILE
reset_m3u()
{
    local file="$1"
    local dir="$(dirname "$1")"

    [[ $file && $dir ]] || error
    
    [[ -d $dir ]] || mkdir -p "$dir" || error "$dir: failed to create directory"
    printf '%s\n' "#EXTM3U" > "$file" || error "$file: failed to write to playlist"
}

# Args: TITLE LINK FILE
write_to_m3u()
{
    local title="$1"
    local link="$2"
    local file="$3"

    [[ $title && $link && $file ]] || error
        
    # Reset the file if empty
    [[ ! -f $file ]] && reset_m3u "$file"

    # Make links to local files relative to the playlist dir
    if [[ ! $link =~ ^https?:// ]]; then
	# --canonicalize-missing = don't care if file exists or not
	link="$(realpath --canonicalize-missing --relative-to="$(dirname "$file")" "$datadir/$link")"
	[[ $link ]] || error
    fi
    
    # If link already is written to file, skip it
    grep -q "^$link$" "$file" && return 0
    
    printf '%s\n' "#EXTINF:0,$title" "$link" >> "$file" || error "$file: failed to write to playlist"
}

# Args: TITLE LINK FILE
write_to_html()
{
    local title="$1"
    local link="$2"
    local file="$3"

    [[ $title && $link && $file ]] || error
        
    # Reset the file if empty
    [[ ! -f $file ]] && reset_html "$file"

    # Make links to local files relative to the playlist dir
    if [[ ! $link =~ ^https?:// ]]; then
	# --canonicalize-missing = don't care if file exists or not
	link="$(realpath --canonicalize-missing --relative-to="$(dirname "$file")" "$datadir/$link")"
	[[ $link ]] || error
    fi
    
    # If link already is written to file, skip it
    grep -q "^$link$" "$file" && return 0

    sed -i '$ d' "$file"
    printf '%s\n' "<a href=\"$link\">$title</a><br><br>" "</body></html>" >> "$file" || error "$file: failed to write to html file"
}

# Args: FILE
reset_html()
{
    local file="$1"
    local dir="$(dirname "$1")"

    [[ $file && $dir ]] || error
    
    [[ -d $dir ]] || mkdir -p "$dir" || error "$dir: failed to create directory"
    printf '%s\n' "<html><head><meta charset=\"utf-8\"/></head><body>" "</body></html>" > "$file" || error "$file: failed to write to html file"
}

# Download a file with curl or wget
# Note: subshell, because it has a trap!
# Args: URL [RATE]
download_file()
(
    local link="$1"
    local file="$2"
    [[ $link ]] || error

    if [[ $file ]]; then
	# Check that file acctually is writable, so we don't try to delete it later
	printf '' >&2 || error "$2: failed to write to file"
	# Redirect output to file
	exec 3>"$2"
	# Remove file if something goes wrong
	trap 'rm -fv "$2"' EXIT
    else
	# Output just goes to stdout
	exec 3>&1
    fi

    [[ $maxrate && $maxrate != 0 ]] && local r="$maxrate"
    
    if ((hascurl)); then
        curl ${r:+--limit-rate "$r"} --silent "$1" 1>&3 || error "failed to download file"
    else
        wget ${r:+--limit-rate "$r"} --quiet -O - "$1" 1>&3 || error "failed to download file"
    fi

    # Download OK, don't delete anything
    trap - EXIT
)

# Check that we have all we need
requirement_check()
{
    for cmd in "$@"; do
	case "$cmd" in

	    sed)
		type sed &>/dev/null || error "this script requires GNU sed"	    
		sed --version | egrep -q "GNU sed" || cat <<EOF 1>&2
Warning:
This script is build for and tested only with GNU sed.
It looks like you are using a different version of sed,
so I cannot guarrantee that it will work.
Just saying :)

EOF
		;;

	    curl|wget)
		if [[ -z $hascurl ]]; then
		    if type curl &>/dev/null; then
			export hascurl=1
		    else
			type wget &>/dev/null || error "this script requires curl or wget"
			export hascurl=0
		    fi
		fi
		;;

	    *)
		type "$cmd" &>/dev/null || error "this script requires the \"$cmd\" command"
		;;
	    
	esac
    done

    return 0
}

# Read the arguments and save variables or do things
# Args: --flag=variable --flag:action -- arguments ...
read_arguments()
{
    until [[ $1 = -- ]]; do
        flags+=("$1")
        shift
        [[ $# = 0 ]] && error
    done

    # Remove the --
    shift

    until [[ $# = 0 ]]; do
        for flag in "${flags[@]}"; do

            # -- means no more flags, only arguments    
            if [[ $1 = -- ]]; then
		shift
		arguments+=("$@")
		return 0
            fi

            # Normal flag
            if [[ $flag =~ --[a-zA-Z0-9-]+:.* && $1 = "${flag%%:*}" ]]; then
                # Run action
                eval "${flag#*:}"
                shift
                continue 2

            # Flag with argument, separated by =
            elif [[ $flag =~ --[a-zA-Z0-9-]+=.* && $1 = "${flag%%=*}"=* ]]; then
                # Check that we have the argument
                [[ ${1#*=} ]] || error "${flag%%=*} requires an argument"
                # Save in variable
                eval "${flag#*=}"'="${1#*=}"'
                shift
                continue 2

            # Flag with argument, separated by space (and argument is not a flag)
            elif [[ $flag =~ --[a-zA-Z0-9-]+=.* && $1 = "${flag%%=*}" && $2 != --* ]]; then
                # Check that we have the argument
                [[ $2 ]] || error "${flag%%=*} requires an argument"
                # Save in variable
                eval "${flag#*=}"'="$2"'
                shift 2
                continue 2

            # An argument, save in array
            elif [[ $1 != --* ]]; then
                arguments+=("$1")
                shift
                continue 2
            fi

        done

        # No matching flag
        error "$1: unknown flag"

    done

    return 0
}

# Check that the language code is valid
# Args: LANGCODE
jwb_check_lang()
{
    [[ $1 ]] || error
    local langurl="http://mediator.jw.org/v1/languages/E/web"
    
    [[ $1 = E || $NOCHECKLANG = 1 ]] && return 0
    # Don't make more checks
    export NOCHECKLANG=1

    # Try to find the language code in the text
    if download_file "$langurl" | grep -q "\"code\":\"$1\""; then
	return 0
    else
	# Download the language list and make it readable
	# CAVEATS:
	# - "name" must be followed by "code"
	echo "Languages:"
	# 1. Download the list
	# 2. Make newline at every opening bracket
	#    where a new language starts
	# 3. Replace "name":"LANG" ... "code":"CODE"
	#    with LANG CODE
	# 4. Sort it
	# 5. Make a nice list with columns
	download_file "$langurl" \
            | sed 's/{/\n/g' \
            | sed -n 's/.*"name":"\([^"]*\)".*"code":"\([^"]*\)".*/\2:\1/p' \
            | sort \
            | column -t -s :
	
	return 1
    fi
}

# Remove a line from files
# Args: FILE ...
remove_from_lists()
{
    local string="$1"
    shift
    
    [[ $string && $@ ]] || error
    
    # Remove a line from the files
    for list in "$@"; do
	[[ ! -e $list ]] && continue
	sed -i "/^${1//\//\\/}$/d" "$list" # replace all / with \/ in $1
    done
}
