# -*- shell-script -*-
#
# functions for jw-scripts
#
# Variables that changes the behaviour:
# mode         Valid values: m3u, m3ucompat, filesystem
# download     If true download the media files
# child        If true we are subprocess (affects some things)
# hascurl      If true use curl, else use wget
# maxrate      Set download rate
# 

error()
{
    echo "${@:-Something went wrong}" 1>&2
    exit 1
}

# Remove everything but the media
clean_dir()
{
    local datadir="$1"

    [[ $datadir ]] || error "Error in $FUNCNAME"

    # If dir doesn't exist, it is clean, right?
    [[ ! -d "$datadir" ]] && return 0
    
    # Remove links
    find "$datadir" -type l -delete
    # Remove playlists
    find "$datadir" -name "*.m3u" -delete
    # Remove empty directories
    find "$datadir" -type d -exec rmdir --ignore-fail-on-non-empty {} +
    # Remove symlinks outside $datadir that point to $datadir
    find "$(dirname "$datadir")" -maxdepth 1 -lname "$datadir/*" -or -lname "$(basename "$datadir")/*" -delete
}

# Make a link (but smarter)
# Args: DEST LINKNAME
create_link()
{
    local dest="$1"
    local link="$2"
    local linkdir="$(dirname "$link")"

    [[ $dest && $link && $linkdir ]] || error "Error in $FUNCNAME"

    # Create dir if not there
    if [[ ! -d $linkdir ]]; then
	mkdir -p "$linkdir" || error "$linkdir: Failed to create directory"
    fi
        
    # Does link exist?
    if [[ -L "$link" ]]; then
	# Is link destination same as we want?
	if [[ $(readlink "$link") = "$dest" ]]; then
	    return 0
	else
	    # If not, remove it
	    rm "$link" || error "$link: Failed to remove link"
	fi
    fi

    # Make the actual link
    # -r makes it relative to link location
    ln -sr "$dest" "$link" || error "$link: Failed to create link"
}

# Add newline around squiggly and square brackets and commas
# but not if they are quoted
# Keep only the lines starting with "KEYWORD":
# and remove all unescaped citation marks
# Args: [KEYWORD ...]
unsquash_file()
{
    local keywordstring

    if [[ $@ ]]; then
        # Append \| to all parameters
        # and remove the last one
        keywordstring="$(printf '%s\|' "$@" | sed 's/\\|$//')" || error "Error in $FUNCNAME"
    else
        # Match everything that's not a citation mark
        keywordstring='[^"]*'
    fi

    sed '
        # Add a newline after all "special" characters
        # Note how the character list starts with an ]
        # Smart huh?
        s/[][{},]/\n&\n/g

' | sed -n '
        : start
        # Does this row have an uneven number of citation marks?
        # That means that the quote continues on the next line...
        /^\([^"\n]*"[^"\n]*"\)*[^"\n]*"[^"\n]*$/ {
            # Append the next line of input
            N
            # Remove the newline between the two lines of input
            s/\n//g
            # Go back to start again
            b start
        }
        # If the line is fine...
        # Grep only the keywords
        /^"\('"$keywordstring"'\)":/ {
            # Remove all unescaped citation marks
            s/\(^\|[^\]\)"\+/\1/g
            # And print it
            p
        }
' || error "Failed to format JSON"
}

# Save link to other playlist/dir
# in current playlist/dir
# Args: NAME DESTCODE DATADIR CODE MAINNAME
write_subdir()
{
    local title="$1"
    local link="$2"
    local datadir="$3"
    local code="$4"
    local name="$5"
    
    [[ $title && $link && $datadir && $code && $name ]] || error "Error in $FUNCNAME"

    case "$mode" in
	filesystem)
	    # Create the directory to link to, before linking to it
	    if [[ ! -d $datadir/$link ]]; then
		mkdir -p "$datadir/$link" || error "$datadir/$link: Failed to create directory"
	    fi

	    # First process saves outside datadir
            if ! ((child)); then
		create_link "$datadir/$link" "$(dirname "$datadir")/$name/$title"
	    else
		create_link "$datadir/$link" "$datadir/$code/$title"
	    fi
	    ;;
	m3u)
	    # First process saves playlist outside of datadir
	    if ! ((child)); then
		write_to_playlist "$title" "$link.m3u" "$(dirname "$datadir")/$name.m3u"
	    else
		write_to_playlist "$title" "$link.m3u" "$datadir/$code.m3u"
	    fi
	    ;;
	m3ucompat)
	    return 0
	    ;;
	urllist)
	    return 0
	    ;;
    esac
    
    return 0
}

# Save media in playlist/dir
# and optionally download them
# Args: TITLE LINK DATADIR CODE NAME [CHECKSUM]
write_media()
{
    local title="$1"
    local link="$2"
    local file="$(basename "$link")"
    local datadir="$3"
    local code="$4"
    local name="$5"
    local destdir="$datadir"
    local checksum="$6"
    
    [[ $title && $link && $file && $datadir && $code && $name ]] || error "Error in $FUNCNAME"

    [[ $mode = urllist ]] && datadir="$(dirname "$datadir")"
    
    # Download media
    if ((download)); then
        if [[ ! -e $datadir/$file ]]; then
	    [[ -d $datadir ]] || mkdir -p "$datadir" || error "$datadir:  Failed to create directory"
            echo "Downloading: $file" 1>&2
            download_file "$link" > "$datadir/$file"
        fi
    fi

    # Change link to point to local media (if any)
    if [[ -e $datadir/$file ]]; then
	if [[ $checksum =~ [0-9a-f]{32} ]]; then
	    # Check checksum
	    if echo "$checksum  $datadir/$file" | md5sum -c --status; then
		link="$file"
	    else
		echo "$datadir/$file: Incorrect checksum, removing file" 1>&2
		rm -f "$datadir/$file"
	    fi
	else
	    link="$file"
	fi
    fi
    
    case "$mode" in
	filesystem)
	    # First process saves outside of datadir
	    if ! ((child)); then
		destdir="$(dirname "$datadir")"
		code="$name"
	    fi

	    # Link to existing media
	    if [[ -e $datadir/$file ]]; then
		suffix="$(sed -n 's/.\+\.//p' <<< "$file")"
		create_link "$datadir/$file" "$destdir/$code/$title.$suffix"
	    else
		# Create a playlist with a URL and link to it
		reset_playlist  "$datadir/$file.m3u"
		write_to_playlist "$title" "$link" "$datadir/$file.m3u"
		create_link "$datadir/$file.m3u" "$destdir/$code/$title.m3u"
	    fi
	    ;;
	m3u)
	    # First process saves playlist outside of datadir
	    if ! ((child)); then
		write_to_playlist "$title" "$link" "$(dirname "$datadir")/$name.m3u"
	    else
		write_to_playlist "$title" "$link" "$datadir/$code.m3u"
	    fi
	    ;;
	m3ucompat)
	    # Save all playlists outside of datadir
	    datadir="$(dirname "$datadir")"

	    write_to_playlist "$title" "$link" "$datadir/$code - $name.m3u"
	    ;;
	urllist)
	    if [[ -e $datadir/$file ]]; then
		echo "$datadir/$file"
	    else
		echo "$link"
	    fi
	    ;;
    esac
    
    return 0
}

# Args: DATADIR CODE NAME
write_empty()
{
    local dir="$1"
    local code="$2"
    local name="$3"
    local file

    [[ $dir && $code && $name ]] || error "Error in $FUNCNAME"

    case "$mode" in
	m3u)
	    # First process saves outside of datadir
	    if ! ((child)); then
		dir="$(dirname "$dir")"
		file="$name.m3u"
	    else
		file="$code.m3u"
	    fi
	    ;;
	m3ucompat)
	    dir="$(dirname "$dir")"
	    file="$code - $name.m3u"
	    ;;
	filesystem)
	    # Remove m3u files that is linked to
	    # Don't do this because they may be used in someother dir
	    #find -L -lname "*.m3u" -delete

	    # Remove all links
	    [[ -e $dir/$code ]] && find "$dir/$code" -type l -delete
	    return
	    ;;
	urllist)
	    return 0
	    ;;
    esac

    reset_playlist "$dir/$file"
}

# Args: FILE
reset_playlist()
{
    local file="$1"
    local dir="$(dirname "$1")"

    [[ $file && $dir ]] || error "Error in $FUNCNAME"
    
    [[ -d $dir ]] || mkdir -p "$dir" || error "$dir:  Failed to create directory"
    printf '%s\n' "#EXTM3U" > "$file" || error "$file: Failed to write to playlist"
}

# Args: TITLE LINK FILE
write_to_playlist()
{
    local title="$1"
    local link="$2"
    local file="$3"

    [[ $title && $link && $file ]] || error "Error in $FUNCNAME"
        
    # Reset the file if empty
    [[ ! -f $file ]] && reset_playlist "$file"

    # Make links to local files relative to the playlist dir
    if [[ ! $link =~ ^https?:// ]]; then
	# --canonicalize-missing = don't care if file exists or not
	link="$(realpath --canonicalize-missing --relative-to="$(dirname "$file")" "$datadir/$link")"
	[[ $link ]] || error "Error in $FUNCNAME"
    fi
    
    # If link already is written to file, skip it
    grep -q "^$link$" "$file" && return 0
    
    printf '%s\n' "#EXTINF:0,$title" "$link" >> "$file" || error "$file: Failed to write to playlist"
}

# Download a file with curl or wget
# Args: URL [RATE]
download_file()
{
    [[ $1 ]] || error "Error in download_file()"

    if ((hascurl)); then
        curl ${maxrate:+--limit-rate "$maxrate"} --silent "$1" || error "Failed to download file"
    else
        wget ${maxrate:+--limit-rate "$maxrate"} --quiet -O - "$1" || error "Failed to download file"
    fi
}

# Check that we have all we need
requirement_check()
{
    type sed &>/dev/null || error "This script requires GNU sed"

    if type curl &>/dev/null; then
        export hascurl=1
    else
        type wget &>/dev/null || error "This script requires curl or wget"
        export hascurl=0
    fi

    sed --version | egrep -q "GNU sed" || cat <<EOF 1>&2
Warning:
This script is build for and tested only with GNU sed.
It looks like you are using a different version of sed,
so I canot guarrantee that it will work for you.
Just saying :)

EOF

    return 0
}

# Read the arguments and save variables or do things
# Args: --flag=variable --flag:action -- arguments ...
read_arguments()
{
    until [[ $1 = -- ]]; do
        flags+=("$1")
        shift
        [[ $# = 0 ]] && error "Error in $FUNCNAME"
    done

    # Remove the --
    shift

    until [[ $# = 0 ]]; do
        for flag in "${flags[@]}"; do

            # -- means no more flags, only arguments    
            if [[ $1 = -- ]]; then
		shift
		arguments+=("$@")
		return 0
            fi

            # Normal flag
            if [[ $flag =~ --[a-zA-Z0-9-]+:.* && $1 = "${flag%%:*}" ]]; then
                # Run action
                eval "${flag#*:}"
                shift
                continue 2

            # Flag with argument, separated by =
            elif [[ $flag =~ --[a-zA-Z0-9-]+=.* && $1 = "${flag%%=*}"=* ]]; then
                # Check that we have the argument
                [[ ${1#*=} ]] || error "${flag%%=*} requires an argument"
                # Save in variable
                eval "${flag#*=}"'="${1#*=}"'
                shift
                continue 2

            # Flag with argument, separated by space (and argument is not a flag)
            elif [[ $flag =~ --[a-zA-Z0-9-]+=.* && $1 = "${flag%%=*}" && $2 != --* ]]; then
                # Check that we have the argument
                [[ $2 ]] || error "${flag%%=*} requires an argument"
                # Save in variable
                eval "${flag#*=}"'="$2"'
                shift 2
                continue 2

            # An argument, save in array
            elif [[ $1 != --* ]]; then
                arguments+=("$1")
                shift
                continue 2
            fi

        done

        # No matching flag
        error "$1: unknown flag"

    done

    return 0
}

# Check that the language code is valid
# Args: LANGCODE
jwb_check_lang()
{
    [[ $1 ]] || error "Error in $FUNCNAME"
    local langurl="http://mediator.jw.org/v1/languages/E/web"
    
    [[ $1 = E || $NOCHECKLANG = 1 ]] && return 0
    # Don't make more checks
    export NOCHECKLANG=1

    # Try to find the language code in the text
    if download_file "$langurl" | grep -q "\"code\":\"$1\""; then
	return 0
    else
	# Download the language list and make it readable
	# CAVEATS:
	# - "name" must be followed by "code"
	echo "Languages:"
	# 1. Download the list
	# 2. Make newline at every opening bracket
	#    where a new language starts
	# 3. Replace "name":"LANG" ... "code":"CODE"
	#    with LANG CODE
	# 4. Sort it
	# 5. Make a nice list with columns
	download_file "$langurl" \
            | sed 's/{/\n/g' \
            | sed -n 's/.*"name":"\([^"]*\)".*"code":"\([^"]*\)".*/\2:\1/p' \
            | sort \
            | column -t -s :
	
	return 1
    fi
}

