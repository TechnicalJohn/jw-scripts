#!/bin/bash
#
# jwb-index
# Index JW Broadcasting (tv.jw.org)
#

load_shared_code()
{
    for code in "$SHARED" ./shared-functions /usr/local/lib/jw-scripts/shared-functions; do
	if [[ -f $code ]]; then
	    if source "$code"; then
		return 0
	    else
		echo "error when reading shared functions" 1>&2
		exit 1
	    fi
	fi
    done

    echo "Cannot find shared functions file" 1>&2
    echo "You can set the default path with the variable SHARED" 1>&2
    exit 1
}

show_help()
{
    cat<<EOF
Usage: jwb-index [OPTIONS] [DIRECTORY]
Index the videos at tv.jw.org

  --lang CODE           Change language
  --list-langs          Show a list of available language codes
  --quality NUM         Select maximum quality: 240, 360, 480 or 720
  --no-subs             Prefer unsubtitled videos
  --latest              Index "Latest Videos" instead of "Video on Demand"
  --mode MODE           The format in which files are saved (see Modes)
  --download            Make videos available offline
  --clean               Clean out all old files except downloaded videos
  --quiet               Only show errors
  DIRECTORY             Directory to save the playlists or videos in

Advanced options:
  --limit-rate RATE     Maximum download rate for videos, default is
                          500k (500 kilobytes per second), 0 disables limit
  --category CODENAMES  Comma separated list of categories to index. Default:
                          VideoOnDemand
  --no-recursive        Don't automatically download more categories
  --no-checksum         Don't check video files
  --json                Don't parse the JSON file, just show it (debug)

Modes:
  m3u                   Write a m3u hierarcy of m3u playlists. You can browse
                          this by opening the first playlist. This works with
                          Kodi, but can confuse other media players.
  m3ucompat             Save multiple m3u playlists in the destination
                          directory. There is no hierarcy, so you will have to
                          open the correct playlist via a file browser, but
                          this should work with most players.
  filesystem            The media is saved in an actual folder hierarchy
                          consisting of directories and symlinks. This is
                          really only useful in combination with --download for
                          media players that cannot read m3u files, e.g. Plex.
  urllist               Simply output a list of URLs or files to stdout.
                          Note that unless --no-recursive is used, a media file
			  can belong to multiple categories and that would
			  cause duplicates in the output.

EOF
    exit
}

# GIGANT CAVEATS:
# - First there must be a "key" followed by "name" where
#    "key" has the same value as --category. This will give
#    us the name of the playlist to save to, and clean it.
# - "key" must be followed by "name". This is a sub-
#    category and will be downloaded and parsed
# - "title" must be followed by "progressiveDownloadURL".
#    This is a media link and will be saved to a playlist
#    and alternatively downloaded.
# - "parentCategory" must be followed by "name" and this
#    will be skipped, since we want to go recursive on
#    DEPTH and not upwards.
# - "primaryCategory" is only used with the --latest flag.
#    It must not be followed by "key". It will cause the
#    media to be saved in the category set by
#    primaryCategory instead of the category set by "key".
#    This has no affect when using --mode=m3ucompat
#    because that requires the REAL name of the category
#    (as opposed to the codename).
#
parse_lines()
{
    # Read stdin
    while read -r input; do
        case "$input" in

	    status:404)
		error "category not found"
		;;
	    
            key:*)
                code="${input#*:}"
                ;;

            parentCategory:)
                # Next name refers to parent category, don't parse it
                local skipnextname=1
                ;;

            primaryCategory:*)
		# Don't use "realcode" in m3ucompat mode since there is no equivalent
		# "realname" that can be used as filename
                ((latest)) && [[ $mode != m3ucompat ]] && realcode="${input#*:}"
                ;;

            name:*)
                # If there is a title an URL, save them
                if [[ $title && $url ]]; then
		    # If this belongs to other category, add it to that one
		    write_media "$title" "$url" "$datadir" "${realcode:-$maincode}" "$mainname" "$checksum"
		    # Unset variables so they don't get repeated
		    unset title url realcode checksum
                fi

		name="${input#*:}"

                ((skipnextname)) && skipnextname=0 && continue

                # First category (self)
                if [[ $code = "$maincode" ]]; then
		    mainname="$name"
		    # Empty out the playlist for this category
		    write_empty "$datadir" "$code" "$name"
                    continue
                fi

                write_subdir "${name^^*}" "$code" "$datadir" "$maincode" "$mainname"

                # Start a new instance - download and parse category
                if ! ((norecursive)); then
                    # Don't download categories we've already checked
                    grep -q "$code" "$histfile" && continue

                    ("$0" --child --category "$code" "$datadir") || error "child process failed" # exit if child process gets error
                fi
                ;;

            title:*)
                # If there is a title an URL, save them
                if [[ $title && $url ]]; then
		    # If this belongs to other category, add it to that one
		    write_media "$title" "$url" "$datadir" "${realcode:-$maincode}" "$mainname" "$checksum"
		    # Unset variables so they don't get repeated
		    unset title url realcode checksum
                fi

                title="${input#*:}"
                ;;

            progressiveDownloadURL:*.mp4)
                newurl="${input#*:}"
                # Already have url? Compare them!
                if [[ $url ]]; then

                    # Prefer subtitles or not
                    if ((nosubtitles)); then
                        # Old one doesn't have subs and new one has
                        [[ $url != *_s-Sub_* && $newurl = *_s-Sub_* ]] && continue
                    else
                        # Old one have subs and new one doesn't
                        [[ $url = *_s-Sub_* && $newurl != *_s-Sub_* ]] && continue
                    fi

                    # Compare quality (old < new <= maximum)
                    newq="$(sed 's/^.*r\([0-9]*\)P\.mp4$/\1/i'<<< "$newurl")" || error "quality comparsion failed"
                    oldq="$(sed 's/^.*r\([0-9]*\)P\.mp4$/\1/i' <<< "$url")" || error "quality comparsion failed"
                    [[ $newq -lt $oldq || $newq -gt $quality ]] && continue

                fi
                # Save URL
                url="$newurl"
		local savenextsum=1
                ;;

	    checksum:*)
		((nomd5)) && continue
		((savenextsum)) && savenextsum=0 && checksum="${input#*:}"
		;;

        esac
    done

    # If there is a title and an URL left when we reach EOF
    # save them to the playlist
    [[ $title && $url ]] && write_media "$title" "$url" "$datadir" "$maincode" "$mainname"

    return 0
}

# Download the language list and make it readable
# CAVEATS:
# - "name" must be followed by "code"
lang_list()
{
    echo "Languages:"
    # 1. Download the list
    # 2. Make newline at every opening bracket
    #    where a new language starts
    # 3. Replace "name":"LANG" ... "code":"CODE"
    #    with LANG CODE
    # 4. Sort it
    # 5. Make a nice list with columns
    download_file "$langurl" \
        | sed 's/{/\n/g' \
        | sed -n 's/.*"name":"\([^"]*\)".*"code":"\([^"]*\)".*/\2:\1/p' \
        | sort \
        | column -t -s :

    exit
}

trap 'echo aborted 1>&2' SIGTERM SIGINT SIGHUP

load_shared_code

read_arguments --help:show_help \
               --list-langs:lang=none \
               --lang=lang \
               --category=maincode \
               --quality=quality \
               --child:child=1 \
               --no-subs:nosubtitles=1 \
               --latest:maincode=LatestVideos\;latest=1 \
               --download:download=1 \
               --no-recursive:norecursive=1 \
               --json:json=1 \
               --filesystem:mode=filesystem \
	       --mode=mode \
	       --limit-rate=maxrate \
	       --clean:clean=1 \
	       --quiet:quiet=1 \
	       --no-checksum:nomd5=1 \
               -- \
               "$@" || exit 1

export lang maincode nosubtitles quality download norecursive maxrate mode latest histfile quiet nomd5
[[ ${#arguments[@]} -gt 1 ]] && error "too many arguments" # $arguments gets set by read_arguments()

# Assign variables
[[ $mode ]] || mode=m3u
[[ $maxrate ]] || maxrate=500k
[[ $maincode ]] || maincode=VideoOnDemand
[[ $quality ]] || quality=720
[[ $lang ]] || lang=E
[[ $maxrate = 0 ]] && unset maxrate
datadir="${arguments[0]:-.}"

# Debug JSON
if ((json)); then
    mainurl="http://mediator.jw.org/v1/categories/$lang/${maincode%%,*}?detailed=1"
    download_file "$mainurl" | unsquash_file | less
    exit
fi

[[ $mode =~ ^(m3u|m3ucompat|filesystem|urllist|html)$ ]] || error "$mode: unknown mode"

# Things that only the parent may do
# or that's only needed once
if ! ((child)); then
    # Do we have all we need?
    requirement_check realpath mktemp
    # Check that lang is valid
    jwb_check_lang "$lang" || exit 1
    # Check datadir
    [[ -d $datadir ]] || error "$datadir: destination directory does not exist"
    # Make path absolute
    datadir="$(realpath "$datadir")"
    # Add a subdir
    datadir="$datadir/jwb-$lang"
    # Cleaning
    ((clean)) && clean_dir "$datadir"
    # History only needed when "recursing"
    if ((norecursive)); then
	histfile=/dev/null
    else
	# Create history file
	histfile="$(mktemp)" || error "failed to create temp file"
	# Remove the history file when we exit
	trap '[[ -e $histfile ]] && rm "$histfile"' EXIT
    fi
fi

# Split codes where commas are
OLDIFS="$IFS"
IFS=,
maincodes=($maincode)
IFS="$OLDIFS"

for maincode in "${maincodes[@]}"; do
    
    mainurl="http://mediator.jw.org/v1/categories/$lang/${maincode}?detailed=1"
    
    # Write to the history file
    # and show a message with our progress
    [[ $histfile ]] || error "histfile: variable empty, this should not happen"
    echo "$maincode" >> "$histfile" || error "$histfile: failed to write to temp file"
    ((quiet)) || echo "$maincode" 1>&2

    # Download and parse the JSON file
    download_file "$mainurl" \
	| unsquash_file status key name title progressiveDownloadURL parentCategory checksum \
	| parse_lines

done

